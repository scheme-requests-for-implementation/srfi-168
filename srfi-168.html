<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI 168: Generic Tuple Store Database</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>
  <body>

    <h1>Title</h1>

    <p>SRFI 168: Generic Tuple Store Database</p>

    <h1>Author</h1>

    <p>Amirouche Boubekki</p>

    <h1>Status</h1>

    <p>This SRFI is currently in <em>draft</em> status.  Here is
      <a href="https://srfi.schemers.org/srfi-process.html">an
	explanation</a> of each status that a SRFI can hold.  To provide
      input on this SRFI, please send email to
      <code><a href="mailto:srfi+minus+168+at+srfi+dotschemers+dot+org">srfi-168@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.
      To subscribe to the list, follow
      <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these
	instructions</a>.  You can access previous messages via the
      mailing list <a href="https://srfi-email.schemers.org/srfi-168">archive</a>.</p>

    <ul>
      <li>Received: 2019/4/13</li>
      <li>60-day deadline: 2019/6/17</li>
      <li>Draft #1 published: 2019/4/18</li>
      <li>Draft #2 published: 2019/4/29</li>
    </ul>

    <h1>Abstract</h1>

    <p>This library is a generic approach to the database abstractions
      known as triplestore and quadstore.  Generic Tuple Store
      Database implements n-tuple ordered sets and associated
      primitives for working with them in the context of data
      management.</p>

    <h1>Rationale</h1>

    <p>The industry standard for durable data storage, namely the
      Relational Database Management System (RDBMS), does not blend
      nicely into Scheme.  In particular, the SQL programming language
      is very difficult to embed in Scheme without fallback to string
      interpolations.  This could explain the poor support of RDBMS in
      Scheme implementations.</p>

    <p>This SRFI proposes a powerful database abstraction for storing
      and querying data that integrates well with the existing Scheme
      landscape by reusing <a href="https://srfi.schemers.org/srfi-9/">SRFI 9</a>,
      <a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a>,
      <a href="https://srfi.schemers.org/srfi-146/">SRFI 146</a>, and
      <a href="https://srfi.schemers.org/srfi-158/">SRFI 158</a>, and
      relying on the <a href="https://srfi.schemers.org/srfi-167">Ordered
	Key Value Store SRFI</a>.  This SRFI comes with a memory
      storage engine that supports transactions.  It can easily be
      adapted to implement durability relying on one of the various
      existing ordered key-value store libraries available in the
      wild.</p>

    <p>This SRFI does not overlap with existing SRFIs.</p>

    <h1>Specification</h1>

    <p>This specification defines four disjoint types:</p>

    <ul>
        <li><code>engine</code> exposes a lexicographically ordered key
	    store interface as described in the Ordered Key Value Store
	    SRFI.</li>
        <li><code>nstore</code> is an n-tuple store database where n is
	    fixed.</li>
      <li><code>variable</code> is an immutable object associated
	  with a symbol.</li>
    </ul>

    <p>Also, an implementation must rely on SRFI-158 generators to
      implement streams and SRFI-146 hash mappings to implement
      bindings.</p>

    <p>The first section describes the <code>engine</code>
        type that allows one to configure the storage mechanism.  The
        second section describes the public interface of the generic
        tuple store abstraction.  </p>

    <h2 id="pluggable-storage-engine">Pluggable Storage Engine</h2>

    <p>The storage engine type exposes the interface described in the
      Ordered Key Value Store SRFI so that it possible to swap one
      storage engine with another seamlessly.</p>

    <h3 id="nstore-engine"><code>(nstore-engine ref set! rm! prefix)</code></h3>

    <p>Return an object suitable to pass to the <code>nstore</code>
        procedure.</p>

    <h3 id="nstore-engine?"><code>(nstore-engine? object)</code></h3>

    <p>Return true if <code>OBJECT</code> is an nstore engine and
    false otherwise.</p>

    <h2 id="generic-tuple-store-database">Generic Tuple Store Database</h2>

    <p>The database abstraction described in this section is an
      ordered set of tuples with <em>n</em> objects.  A given store
      will always contain tuples of the same length.  Tuples are
      always passed as rest arguments to the database procedures.</p>

    <h3 id="nstore"><code>(nstore engine prefix items)</code></h3>

    <p>Return an <code>nstore</code> object. <code>ENGINE</code> is
        described above.  <code>DATABASE</code> is an okvs object as
        described in SRFI-167.  <code>ITEMS</code> describes the names
        given to a tuple’s items.  It should be a list of symbols.</p>

    <p>In the following, <code>ITEMS</code> is always a list of Scheme
        objects.  What is accepted in the <code>ITEMS</code> list depends on
        the implementation.</p>

    <h3 id="nstore-predicate"><code>(nstore? object)</code></h3>

    <p>Return a <code>#t</code> if <code>OBJECT</code> is an nstore
        object and <code>#f</code> otherwise.</p>

    <h3 id="nstore-ask"><code>(nstore-ask? some nstore items)</code></h3>

    <p>Must be decorated with SRFI-167 <code>transactional</code> so
        that it is possible to pass a transaction or a database object
        as first argument.</p>

    <p>Return <code>#t</code> if <code>ITEMS</code> is present in the
      store associated with <code>SOME</code>.  Otherwise,
      return <code>#f</code>.</p>

    <h3 id="nstore-add"><code>(nstore-add! some nstore items)</code></h3>

    <p>Must be decorated with SRFI-167 <code>transactional</code> so
      that it is possible to pass a transaction or a database object
      as first argument.</p>

    <p>Add <code>ITEMS</code> to the store associated with
      <code>SOME</code>.  If <code>ITEMS</code> is already in the
      associated store, do nothing.  Return value is unspecified.</p>

    <h3 id="nstore-rm"><code>(nstore-rm! some nstore items)</code></h3>

    <p>Must be decorated with SRFI-167 <code>transactional</code> so
      that it is possible to pass a transaction or a database object
      as first argument.</p>

    <p>Remove <code>ITEMS</code> from the store associated with
      <code>SOME</code>.  Do nothing if <code>ITEMS</code>
      is not in the store.  Return value is unspecified.</p>

    <h3 id="nstore-var"><code>(nstore-var name)</code></h3>

    <p>Return an object of a disjoint type <code>nstore-var</code>
      associated with the symbol <code>NAME</code>.</p>

    <h3 id="nstore-var-predicate"><code>(nstore-var? obj) → boolean</code></h3>

    <p>Return <code>#t</code> if <code>OBJ</code> is a variable as
      returned by <code>nstore-var</code> procedure.  Otherwise, return
      <code>#f</code>.</p>

    <h3 id="nstore-var-name"><code>(nstore-var-name variable) → symbol</code></h3>

    <p>Return the symbol name associated with <code>VARIABLE</code>.
      If <code>VARIABLE</code> is not a variable is the sense of
      <code>var?</code>, the returned value is unspecified.</p>

    <h3 id="nstore-from"><code>(nstore-from transaction nstore pattern [config]) → generator</code></h3>

    <p>Return a generator of bindings where variables (in the sense of
      <code>nstore-var?</code>) of <code>PATTERN</code> are bound against one or
      more <em>matching</em> tuples from the store associated with
      <code>TRANSACTION</code>.  The implementation must return a
      SRFI-158 generator of SRFI-146 hash mappings.</p>

    <p>Note: the generator is valid as long as the transaction is running.
        If the transaction is commited the generator will not be able to
        proceed.</p>

    <p>The returned generator is called the <em>seed</em> generator
        because it doesn’t rely on an existing generator of bindings.</p>

    <p><code>CONFIG</code> is an optional association list that allows
        to configure the returned generator. It takes the following
        options:</p>

    <table>
        <thead>
            <tr>
                <th>key</th>
                <th>description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>'offset</code></td>
                <td>specify how many bindings must be skipped.</td>
            </tr>
            <tr>
                <td><code>'limit</code></td>
                <td>indicates the maximum number of bindings to return.</td>
            </tr>
        </tbody>
    </table>

    <h3 id="nstore-where"><code>(nstore-where transaction nstore pattern) → procedure → generator</code></h3>

    <p>Return a procedure that takes a generator of bindings as
      argument and returns a generator of bindings where variables of
      <code>PATTERN</code> are bound to one or more <em>matching</em>
      tuples from the store associated with
      <code>TRANSACTION</code>.</p>

    <p>Note: The generator returned by <code>nstore-where</code> is flat.  It
        is NOT a generator of generators.</p>

    <p>Note: the generator is valid as long as the transaction is running.
        If the transaction is commited the generator will not be able to
        proceed.</p>

    <h3 id="nstore-select"><code>(nstore-select &lt;from&gt; &lt;where&gt; ...)</code> syntax</h3>

    <p><code>nstore-select</code> allows one to compose <code>nstore-from</code>
        with one or more <code>nstore-where</code> to execute a query.</p>

    <h1>Implementation</h1>

    <p>Here is the <a href="https://srfi.schemers.org/srfi-168/srfi-168.tgz">sample
      implementation</a>.</p>

    <h1>Acknowledgements</h1>

    <p>Credit goes first to <a href="https://cognitect.com/">Cognitect</a>
      for creating the <a href="https://www.datomic.com/">Datomic</a>
      database which inspired this work.  <a href="https://stackoverflow.com/">StackOverflow</a>
      user <a href="https://stackoverflow.com/users/9433491/zhoraster">zhoraster</a>
      helped pin the mathematics behind the generic implementation of
      n-tuple stores and Mike Earnest provided an algorithm to compute
      the minimal set of tuple items permutations that allows
      efficient querying.  The author would like to thank Arthur
      A. Gleckler and Marc Nieper-Wißkirchen for getting together SRFI
      146 and Shiro Kawai, John Cowan, and Thomas Gilray for working
      on SRFI 158.</p>

    <h1>Copyright</h1>

    <p>Copyright (C) Amirouche Boubekki (2019).</p>

    <p>Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation
      files (the “Software”), to deal in the Software without
      restriction, including without limitation the rights to use,
      copy, modify, merge, publish, distribute, sublicense, and/or
      sell copies of the Software, and to permit persons to whom the
      Software is furnished to do so, subject to the following
      conditions:</p>

    <p>The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the
      Software.</p>

    <p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
      BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
      ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.</p>
  </body>
</html>
